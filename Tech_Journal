Итак, здесь предстоит записывать каждую мою мысль по интерпретации понятого мною при разборе проекта snow-crash.
Установка ОС:
ОС устанавливается очень легко. Достаточно просто выделить машину с любыми требованиями и подключить как внешний образ сам образ из интры.
Дальше идём на разбор задания.
Задача:
Оценивается только человеком.
Возможно нужно будет доказать свои результаты, обосновать. Надо быть к этому готовым.
После запуска образа мы увидим IP адрес с которым работаем.
Пароль и логин level00:level00
После того как залогинились, мы должны получить пароль - флаг от XX уровня.
Есть возможность использовать ssh ключ с портом 4242 для подключения.
Залогинившись, запускаем команду getflag. Настоящая команда должна выдать мне пароль к следующему уровню. Мы можем не иметь возможности связаться с flagXX учёткой. В этом случае нужно найти альтернативный метод как команды инъекции в программе зависимостей от её прав, например.
После того как получили флаг от уровня, дальше запускаем команду 
su flag00
Вводим пароль, полученный как токен с предыдущего.
Сначала su flag00, вводим полученный пароль. Дальше запускаем getflag, чтобы получить токен. Дальше su level01, вводим этот пароль и так далее.
Нам могут помочь на некоторых уровнях внешние программы. Нам следует изучить как использовать SCP команды.
SCP команды это сетевой протокол передачи файлов между локальным и удалённым хостом. SCP is Secure Copy.
Папки tmp/ и /var/tmp являются ограниченными в паравах и могут быть сброшены время от времени. Нам не следует работать непосредственно в самих машинах.

Обязательная часть:
Наш репозиторий включает всё, что может помочь нам решить каждый раз валюдацию теста.
Каждый уровень прохода в отдельной папке. В каждой папке Ресурсы и флаг как отдельный файл. В папке Ресурсов всё что необходимо для нас самих, без разницы.
Если флаг пустой, то нам следует объяснить почему он пустой и как мы взломали без него.
Мне нужно понятно и точно объяснять всё то, что есть в папке. Папка не должна включать в себя бинарные файлы (т.к. этим ничто не раскрывается как взломал).
Если необходимы специфичные файлы, которые включены в проект ИСО, то должен загрузить их в процессе проверки. И никаких программ не помещать, кроме текстовых файлов в репозиторий.
Если планирую устанавливать сторонние программы, то запускать их следует строго через внешние окружения.
Можно создавать скрипты для взлома, но следует их объяснять в процессе оценки.
В обязательном случае должен раскрыть все 10 учёток. 
Нельзя перебирать ssh-флаги, т.к. это не решение.
Как бонус - ещё 5 учёток.


Начинаем с нулевого уровня:
Внутри нет ни единой директории.
Мы не можем войти в другие директории, но можем выйти в usr директорию.
Через команду cat /etc/passwd можно увидеть всех пользователей.

Вопрос в том как подключиться к виртуальной машине через ssh код. Возможно, что я неправильно настраивал его в программе виртуализации. Поэтому сначала исследуем как войти в неё, а дальше пробуем сначала взломать getflag программу. Может быть сдать одним этим взломом весь проект?
Пока думаю над этим всем. Следует красиво обосновать и то, как ты пришёл к этому выводу

find / -user flag00 
find - поиск
/ - всюду
-user - где владельцем является flag00.

через эту команду ищем файлы, которые принадлежат пользователю. Всюду видим, что нет прав доступа, но есть два адреса куда доступ есть, это user/sbin/john и /rofs/usr/sbin/john.
Начинаем их исследовать. По содержанию одно и то же. В подсказке на видео есть ссылка на сайт шифрования. Мы берем найденную строку и переходим на этот сайт, а там через рут подбираем, и находим, что рут 11 в сайте. Т.е. 26 смещений. Ищем смещения и находим. Так мы получим пароль к флагу, а взяв флаг, мы получаем пароль к следующему уровню.



Level00:
Сначала видим какие файлы доступны для нашего настоящего пользователя через команду
find / -user flag00
Здесь обнаруживаем два файла, которые по содержанию одинаков. Проверяем содержание через cat.
Так сам как пароль не подходит, однако в видео была подсказка в виде сайта, что пароли зашифроны. И есть сайт https://www.dcode.fr/caesar-cipher
где мы проверяем зашифрован ли. Из всех слов со смещением только одно здесь читабельное. 
Пробуем его nottoohardhere - всё ок.
В терминале вбиваем su flag00 и передаём пароль, получаем токен для следующего уровня. x24ti5gi3x0ol2eh4esiuxias



level01:
До этого искал где хранятся пароли линукс и обнаружил через гугл (http://manpages.ubuntu.com/manpages/bionic/ru/man5/passwd.5.html)
Смотрим через команду cat /etc/passwd и обнаруживаем пароль от flag01. Но он не подходит. 42hDRfypTqqnw
Есть программа john, которая тоже с видео. Скачал её https://download.openwall.net/pub/projects/john/contrib/macosx/ отсюда. Разархивируем и заходим в run директорию через терминал. Запускаем программу john и передаём как аргумент файл с содержанием шифра, который получили.
./john <файл с паролем> --show
--show флаг нужен, если ранее уже john запускали с этим файлом для раскрытия хэша с паролем
Получаем просто первые буквы алфавита abcdefg
getflag : f2av5il02puano7naaf6adaaf
Дальше su level02  и подстановка токена.



level02:
Файл формата .pcap содержит данные сетевых пакетов, перехваченных программой-анализатором трафика Wireshark.
Чтобы скопировать этот файл, закидываем её через следующую команду
scp - для копирования по ssh в зашифрованном, безопасном формате между двумя серверами через порт 4242
 -P 4242 level02@192.168.56.102:/home/user/level02/level02.pcap - вводим в НАШЕМ компе, чтоб скачал с виртуалки.
chmod 777 level02.pcap чтобы были права на чтение.
Дальше открываем через Wireshark. По строкам не понять где находится пароль. Поэтому запускаем Анализ по TCP Stream
TCP Stream - определяет с какой ОС, с какого браузера отслеживался этот трафик. Здесь мы видим ft_wandr...NDRel.L0L - однако он не подходит.
Если перевести в 16-ричную систему, то увивдим в символах, что между буквами есть 7f, переводим её в десятиричную, открываем ASCII и видим, что это delete. 
Значит пользователь ввёл:
ft_wandr
дальше три раза нажал на удаление
ft_wa
продолжил
ft_waNDRel
ещё видим 7f, значит удалил один символ с конца
ft_waNDRe
Дальше продолжил
ft_waNDReL0L
А символ 0d - значит возврат корретки, пропускаем.

su flag02: ft_waNDReL0L
getflag: kooda2puivaav1idi4f57q8iq



level03:
Видим level03 файл. Если посмотрим по содержанию, то понятно, что здесь похоже что-то на башное. Запускаем через bash и видим текст "Взломай меня".
Есть команда ltrace, которая выводит весь список вызываемых функций, которые вызваны из разделяемых библиотек.
Т.е. это библиотеки наподобии string, stdio.
Так мы вызываем ltrace для этой програмки.
ltrace ./level03

getuid, geteuid - получить идентифкатор пользоватля
setresuid, setresgid - устанавливает идентификатор реальной, эффективной и сохранненной групп пользователей.  
А затем вызывается системная функция echo для вывода текста.

Создать символическую ссылку getflag как echo в tmp/echo
ln -s /bin/getflag /tmp/echo - чтобы подменить echo на вызов getflag
PATH="/tmp" - чтобы указать где искать системные программы.
Храним в tmp, т.к. в это окружение создаётся на время, а далее восстанавливает всё содержимое изменений как было в системе.

Т.к. мы заменили путь PATH, то восстанавливаем для корректной работы
PATH="/bin"
password: qi0maab88jeaj46qoumi7maus



level04:
Здесь есть файл
Файл PL - это сценарий, написанный на высокоуровневом языке программирования Perl
#!/usr/bin/perl
# localhost:4747
use CGI qw{param};
print "Content-type: text/html\n\n";
sub x {
  $y = $_[0];
  print `echo $y 2>&1`;
}
x(param("x"));
Он настроит общий интерфейс шлюза, через который сервер Apache будет запускать программу и возвращать ее выходные данные.
В файле описывается используемое окружение
Далее хост, на котором он расположен
Далее подключается библиотека.
Печатается содержимое текст.
Переменные начинаются с $
Со слов sub начинается функция x
Переменной присвается переданное значение из параметров.
Т.е. когда передаем параметры, то они хранятся обычно в $_[0] и $_[1].
А дальше есть подсказка использовать CGI.
А CGI предполгает передачу параметров через скрипт.
По факту это описанная веб-страница на порту 4747, которая получает аргумент и обрабатывает её, выводя тем самым токен.
Через команду netstat -lt мы можем увидеть какие порты открыты.
Видим, что 4747 открыт, соот-но отправляем через команду curl, которая 
передаёт ссылки - аргументы.
curl localhost:4747?x=\'getflag\'

Т.е. в perl коде подсказка для нас о том, что 4747 порт слушает и принимает аргументы. Чтобы понять это, можно отправлять разные аргументы и он их выведет. А вот если отправить getflag, то он выдаст нам токен

Теперь запустим и передадим аргумент
./level04 x="hello"
Мы видим как он запускается с ошибками, но при этом выводит текст.
А если передать через апостроф, то будет воспринимать как команду
./level04.pl x=`whoami`
Выдаст имя учётки.

А теперь чтобы получить результат, нужно передать по этому порту выше 4747

curl - передаёт запросы по шлюзу
curl 'localhost:4747/level04.pl?x=`getflag`'

password: ne2searoevaevoem4ov4ar8ap



level05:
Внутри ничего нет. Ищём файлы, которые доступны этому пользователю через команду 
find / -user flag05
здесь видим доступными:
/rofs/usr/sbin/openarenaserver
/usr/sbin/openarenaserver

cat /usr/sbin/openarenaserver - смотрим содержимое
#!/bin/sh

for i in /opt/openarenaserver/* ; do
    (ulimit -t 5; bash -x "$i")
    rm -f "$i"
done

А если посмотреть почту
cat /var/mail/level05
то увидим, что есть письмо, в котором говорится как запускается скрипт через рут права 
*/2 * * * * su -c "sh /usr/sbin/openarenaserver" - flag05

По скрипту видим, что это баш скрипт, в нём проходимся по файлам
Соответственно он ждёт определенный файл в своей директории, чтобы его запустить.
Внутри цикла он выполняет команду ulimit - для бесперебойной обработки задач, далее через баш запускается файл. Флаг -x указывает, чтобы каждая команда оболочки печаталась перед её выполнением для диагностики.

Создаё

вводит команду гетфлаг через апостроф в tmp/token, затем tmp/token вносит в новый файл /tmp/getflag.sh
Затем заменяет закидывает файл в opt/openarenaserver
смотрит затем файл tmp/token, в котором гетфлаг заменён токеном.
Почему? Чтобы выполнить скрипт от рут прав.
Изучить https://github.com/mathyba/snowcrash